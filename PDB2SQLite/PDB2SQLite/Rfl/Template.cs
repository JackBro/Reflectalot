using System;
using System.Collections.Generic;
using System.Text;

namespace Rfl
{
    //
    // NOTE: You can't do typeof(std::vector<>) in C++ since multiple functions get generated by the compiler,
    // dependent upon the template parameter types. However, if you wanted to do typeof(std::vector<int>) you
    // would also have to allow typeof(std::vecto<char>), or any other parameter type. This would require the
    // template class to store a list of all typeof functions, rather than just a single address.
    //
    public class Template : Rfl.Type
    {
        public Template(Scope parent_scope, string name) :
            base(parent_scope, name, 0, 0)
        {
        }

        public static string[] ParseInstance(string type_name, int start_index)
        {
            // Start building a list of template parameter names
            int template_nesting = 1;
            List<string> parameter_strings = new List<string>();
            string cur_parameter = "";

            for (int i = start_index + 1; i < type_name.Length; i++)
            {
                // Keep track of the template nesting level
                if (type_name[i] == '<')
                    template_nesting++;
                else if (type_name[i] == '>')
                    template_nesting--;

                // Is this the closing template bracket?
                if (template_nesting == 0)
                {
                    parameter_strings.Add(cur_parameter.Trim());
                    break;
                }

                // Check for template parameter separation
                if (type_name[i] == ',' && template_nesting == 1)
                {
                    parameter_strings.Add(cur_parameter);
                    cur_parameter = "";
                }

                else
                {
                    cur_parameter += type_name[i];
                }
            }

            return parameter_strings.ToArray();
        }
    }


    //
    // These types are implicitly reflected when specified as parameters, provided the parent template has
    // been reflected.
    //
    public class TemplateInstance : Rfl.Type
    {
        [XmlTypeNameSerialiser]
        public Template InstanceOf;

        // For now only use the first two parameter types (enough for a map)
        [XmlTypeNameSerialiser]
        public Type Type0 = null;
        [XmlTypeNameSerialiser]
        public Type Type1 = null;

        public TemplateInstance(Scope parent_scope, string name, uint size, uint typeof_va, Template instance_of, Type type0, Type type1) :
            base(parent_scope, name, size, typeof_va)
        {
            MinimalReflection = true;
            InstanceOf = instance_of;
            Type0 = type0;
            Type1 = type1;
        }
    }
}
